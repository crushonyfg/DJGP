install.packages("R.matlab")
knitr::opts_chunk$set(echo = TRUE)
# install.packages("R.matlab")
library(R.matlab)
m <- readMat("OHTDataset.mat")
View(m)
View(m)
# install.packages("R.matlab")
# 1. 安装并加载所需包
install.packages(c("R.matlab","tgp","scoringRules"))
library(R.matlab)
library(tgp)
knitr::opts_chunk$set(echo = TRUE)
# install.packages("R.matlab")
# 1. 安装并加载所需包
install.packages(c("R.matlab","tgp","scoringRules"))
library(R.matlab)
library(tgp)
library(scoringRules)
# 2. 读取 .mat 文件（假设文件名 data.mat）
m <- readMat("OHTDataset.mat")
# 提取变量到 R 对象
# 注意 readMat 会把所有变量放到列表 m 中，名字要看 m 的元素名
# 假设 m 中有 "x","y","xt","yt"：
x  <- m$x    # 训练输入矩阵或向量 (n × d)
y  <- c(m$y) # 训练响应向量 (n)
xt <- m$xt   # 测试输入 (n_test × d)
yt <- c(m$yt)# 测试真实响应 (n_test)
# 3. 用 tgp 拟合 Treed GP
#    这里用 btgp（全贝叶斯版）；如果数据维度过高也可以用 bgp（经验贝叶斯）
set.seed(42)
fit <- btgp(X = x, Z = y,
BTE = c(1000, 2000, 2),   # burn-in=1000, keep=2000, thin=2
R = 1000,                 # 后验抽样总数
verb = 0)                 # 关闭中间输出
install.packages(c("R.matlab", "tgp", "scoringRules"))
knitr::opts_chunk$set(echo = TRUE)
# install.packages("R.matlab")
# 1. 安装并加载所需包
install.packages(c("R.matlab","tgp","scoringRules"))
library(R.matlab)
library(tgp)
library(scoringRules)
# 2. 读取 .mat 文件（假设文件名 data.mat）
m <- readMat("OHTDataset.mat")
# 提取变量到 R 对象
# 注意 readMat 会把所有变量放到列表 m 中，名字要看 m 的元素名
# 假设 m 中有 "x","y","xt","yt"：
x  <- m$x    # 训练输入矩阵或向量 (n × d)
y  <- c(m$y) # 训练响应向量 (n)
xt <- m$xt   # 测试输入 (n_test × d)
yt <- c(m$yt)# 测试真实响应 (n_test)
# 3. 用 tgp 拟合 Treed GP
#    这里用 btgp（全贝叶斯版）；如果数据维度过高也可以用 bgp（经验贝叶斯）
set.seed(42)
fit <- btgp(X = x, Z = y,
BTE = c(1000, 2000, 2),   # burn-in=1000, keep=2000, thin=2
R = 1000,                 # 后验抽样总数
verb = 0)                 # 关闭中间输出
install.packages(c("R.matlab", "tgp", "scoringRules"))
# 4. 在 xt 上做预测
pred <- predict(fit, XX = xt)
# pred 里包含：
#  pred$ZZ.kp   —— posterior predictive 均值向量 (n_test)
#  pred$ZZ.ks2  —— posterior predictive 方差向量 (n_test)
m_pred <- pred$ZZ.kp
s_pred <- sqrt(pred$ZZ.ks2)
# 5. 计算 RMSE
rmse <- sqrt(mean((m_pred - yt)^2))
cat("RMSE =", rmse, "\n")
# 6. 计算 CRPS（假设每点预测服从 N(mean, sd^2)）
crps_vals <- crps_norm(y = yt, mean = m_pred, sd = s_pred)
crps  <- mean(crps_vals)
cat("CRPS =", crps, "\n")
fit <- btgp(
X    = x,
Z    = y,
corr = "expsep",    # 分维幂指数核
eK   = 2            # 幂指数设置为 2，即 Squared Exponential
)
help(btgp)
fit <- btgp(
X    = x,
Z    = y,
corr = "expsep"
)
pred <- predict(fit, XX = xt)
m_pred <- pred$ZZ.kp
s_pred <- sqrt(pred$ZZ.ks2)
rmse <- sqrt(mean((m_pred - yt)^2))
cat("RMSE =", rmse, "\n")
crps_vals <- crps_norm(y = yt, mean = m_pred, sd = s_pred)
crps  <- mean(crps_vals)
cat("CRPS =", crps, "\n")
View(pred)
m_pred <- pred$ZZ.kp
pred$Zp.mean
pred$ZZ.mean
m_pred <- pred$ZZ.mean
s_pred <- sqrt(pred$ZZ.ks2)
# 5. 计算 RMSE
rmse <- sqrt(mean((m_pred - yt)^2))
cat("RMSE =", rmse, "\n")
# 6. 计算 CRPS（假设每点预测服从 N(mean, sd^2)）
crps_vals <- crps_norm(y = yt, mean = m_pred, sd = s_pred)
crps  <- mean(crps_vals)
cat("CRPS =", crps, "\n")
m_pred <- pred$Zp.km
s_pred <- sqrt(pred$Zp.ks2)
# 5. 计算 RMSE
rmse <- sqrt(mean((m_pred - yt)^2))
cat("RMSE =", rmse, "\n")
# 6. 计算 CRPS（假设每点预测服从 N(mean, sd^2)）
crps_vals <- crps_norm(y = yt, mean = m_pred, sd = s_pred)
crps  <- mean(crps_vals)
cat("CRPS =", crps, "\n")
m_pred <- pred$ZZ.km
s_pred <- sqrt(pred$ZZ.ks2)
# 5. 计算 RMSE
rmse <- sqrt(mean((m_pred - yt)^2))
cat("RMSE =", rmse, "\n")
# 6. 计算 CRPS（假设每点预测服从 N(mean, sd^2)）
crps_vals <- crps_norm(y = yt, mean = m_pred, sd = s_pred)
crps  <- mean(crps_vals)
cat("CRPS =", crps, "\n")
